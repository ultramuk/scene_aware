# C++ 테스트 코딩 스타일 규칙

Version v1.0
Created 2025-06-26
Owner @kmlim

---

## 0. 개요

- **목적** C++ 테스트 작성 시 일관성, 가독성, 유지보수성을 보장하기 위한 코딩 표준과 모범 사례를 정의합니다.
- **범위** 이 프로젝트 내에서 Catch2 프레임워크를 사용하는 모든 테스트 코드 (`tests/**/*.cpp`).
- **대상** 프로젝트에 기여하는 모든 C++ 개발자.

---

## 1. 목차

1. [핵심 원칙](#2-핵심-원칙)
2. [네이밍 컨벤션](#3-네이밍-컨벤션)
3. [스타일 규칙](#4-스타일-규칙)
4. [테스트 시스템 가이드](#5-테스트-시스템-가이드)
5. [테스트 실행 및 관리](#6-테스트-실행-및-관리)

---

## 2. 핵심 원칙

### 원칙 1 테스트는 명확하고 읽기 쉬워야 합니다

- **범위** 모든 테스트 케이스.
- **근거** 테스트는 시스템 동작의 살아있는 문서 역할을 합니다. 명확한 테스트는 이해하고 유지보수하기 쉬워 실패를 진단하기 간단합니다. Arrange-Act-Assert (AAA) 패턴은 이를 달성하기 위한 주요 도구입니다.

### 원칙 2 테스트는 독립적이고 반복 가능해야 합니다

- **범위** 모든 테스트 케이스.
- **근거** 각 테스트는 다른 테스트의 상태에 의존하지 않고 독립적으로 실행되어야 합니다. 이는 테스트 결과가 결정적이고 실행 순서에 영향을 받지 않도록 보장하며, 신뢰할 수 있는 CI/CD 파이프라인에 매우 중요합니다.

---

## 3. 네이밍 컨벤션

> **설명** 일관된 네이밍은 자동화된 테스트 등록 및 실행 시스템에 매우 중요합니다.

| 코드 요소 | 네이밍 스타일 | 예시 |
| :--- | :--- | :--- |
| 테스트 파일 | `snake_case.cpp` | `my_feature.cpp` |
| `TEST_CASE` 태그 | `[snake_case]` | `[my_feature]` |
| `TEST_CASE` 이름 | 설명적인 문장 | `"나의 새로운 기능 검증"` |

---

## 4. 스타일 규칙

### 4.1 테스트 구조

#### 규칙 1 Arrange-Act-Assert (AAA) 패턴을 사용하여 테스트를 구조화합니다

- **범위** 모든 `TEST_CASE` 블록의 본문.
- **근거** AAA 패턴은 명확하고 일관된 구조를 제공하여 테스트 설정, 실행, 검증을 분리합니다. 이는 가독성과 유지보수성을 크게 향상시킵니다.

```cpp
# GOOD
TEST_CASE("나의 새로운 기능 검증", "[my_feature]") {
    // Arrange: 테스트 조건 설정
    int input = 2;
    int expected = 4;

    // Act: 테스트 대상 코드 실행
    int result = my_project::MyFunction(input);

    // Assert: 결과 검증
    REQUIRE(result == expected);
}

# BAD
TEST_CASE("기능 테스트", "[my_feature]") {
    // 불분명한 구조, 설정과 단언이 혼재됨
    REQUIRE(my_project::MyFunction(2) == 4);
}
```

### 4.2 네이밍 및 태깅

#### 규칙 1 TEST_CASE 태그는 파일명과 일치해야 합니다

- **범위** 모든 `TEST_CASE` 선언.
- **근거** 빌드 시스템은 파일명을 사용하여 CTest를 위한 테스트 이름과 태그를 생성합니다. 일치하는 태그(예: `[my_feature]`에 대한 `my_feature.cpp`)는 테스트가 자동으로 발견되고 실행되기 위해 **필수**입니다.

```cpp
# GOOD
// 파일: tests/unit/my_feature.cpp
TEST_CASE("나의 새로운 기능 검증", "[my_feature]") {
    // ...
}

# BAD
// 파일: tests/unit/my_feature.cpp
TEST_CASE("나의 새로운 기능 검증", "[some_other_tag]") {
    // 이 테스트는 CTest 필터에 의해 올바르게 등록되거나 실행되지 않습니다.
}
```

### 4.3 단언

#### 규칙 1 중요한 검사에는 `REQUIRE`를 사용합니다

- **범위** 모든 단언.
- **근거** `REQUIRE` 는 실패 시 즉시 테스트 케이스를 중단합니다. 검사가 실패하면 나머지 테스트 케이스가 의미가 없는 경우(예: 객체를 사용하기 전에 생성되었는지 확인)에 사용합니다.

#### 규칙 2 중요하지 않은 검사에는 `CHECK`를 사용합니다

- **범위** 모든 단언.
- **근거** `CHECK`는 실패를 보고하지만 테스트 케이스가 계속 진행되도록 합니다. 이는 객체의 여러 속성을 검증할 때 유용하며, 첫 번째 실패만 보는 대신 모든 실패를 한 번에 볼 수 있게 해줍니다.

```cpp
# GOOD
TEST_CASE("객체 속성 검증", "[object_test]") {
    // Arrange
    MyObject obj = CreateObject();

    // Assert
    REQUIRE(obj.IsValid()); // 객체가 유효하지 않으면 이후 검사는 의미가 없습니다.

    CHECK(obj.GetPropertyA() == "expected_A");
    CHECK(obj.GetPropertyB() == "expected_B");
}
```

---

## 5. 테스트 시스템 가이드

### 5.1 전제 조건

- **설명**: 테스트 자동화 파이프라인에는 특정 의존성이 필요합니다. 주요 의존성은 코드 커버리지 분석을 위한 `gcovr`입니다.
- **설치**: OS별 설치 스크립트는 `script/os/` 디렉토리에 제공됩니다.

- **macOS**:

  ```bash
  ./test/script/os/macos/install_gcovr.sh
  ```

- **Ubuntu**:

  ```bash
  ./test/script/os/ubuntu/install_gcovr.sh
  ```

### 5.2 자동화된 테스트 파이프라인

- **1. 구현**: 개발자는 정의된 규칙에 따라 `tests/` 디렉토리 내에 테스트 소스 코드를 작성합니다.
- **2. 등록 (CMake)**: 빌드 시, CMake는 `test/cmake/register_test_case.cmake` 모듈을 통해 자동으로 새 테스트 파일을 발견하고 CTest 스위트에 등록합니다.
- **3. 실행 (CTest)**: 빌드가 성공하면, `run_all_tests` 타겟의 `POST_BUILD` 명령이 CTest를 트리거하여 등록된 모든 테스트를 실행합니다.
- **4. 품질 보증 (gcovr)**: 코드 커버리지가 활성화된 경우 (`ENABLE_COVERAGE=ON`), `test/cmake/check_code_coverage.cmake` 모듈은 `gcovr`를 호출하여 커버리지를 분석합니다. 테스트가 실패하거나 커버리지 지표가 요구되는 임계값 미만이면 빌드가 실패하여 코드 품질을 강제합니다.

### 5.3 시스템 아키텍처

- **`CMakeLists.txt` (Root)**
  - `BUILD_TESTING`: 전체 테스트 빌드 프로세스를 활성화하거나 비활성화하는 전역 옵션입니다.
  - `CMAKE_MODULE_PATH`: `test/cmake/` 디렉토리를 모듈 검색 경로에 추가하여 `include()`를 통해 커스텀 함수를 호출할 수 있도록 합니다.
  - `FUNCTION_COVERAGE` / `LINE_COVERAGE`: `gcovr`에 대한 최소 커버리지 임계값을 정의합니다.

- **`test/cmake/register_test_case.cmake`**
  - **목적**: 테스트 소스 파일을 CTest 케이스로 변환합니다.
  - **프로세스**:
    1. CTest를 위한 고유한 테스트 이름(예: `unit.my_feature`)과 Catch2를 위한 태그(예: `[my_feature]`)를 파일 경로에서 생성합니다.
    2.개별 실행을 허용하는 명령(예: `run_all_tests [my_feature]`)을 지정하여 `add_test`를 통해 테스트를 등록합니다.
    3. 그룹 실행을 위해 최상위 디렉토리를 기반으로 레이블(예: `unit`)을 할당합니다.

- **`test/cmake/check_code_coverage.cmake`**
  - **목적**: 커버리지 측정 및 검증을 자동화합니다.
  - **프로세스**:
    1. `--coverage` 컴파일러 및 링커 플래그를 빌드 타겟에 추가하여 GCC/Clang이 커버리지 데이터를 생성하도록 지시합니다.
    2. `gcovr`를 실행하는 빌드 후 명령을 추가합니다. `gcovr`는 임계값에 대해 커버리지를 검증하고 HTML 보고서를 생성합니다.

---

## 6. 테스트 실행 및 관리

- **컨텍스트**: 모든 명령어는 `build/` 디렉토리에서 실행됩니다.

| 카테고리             | 명령어                               | 설명                                                     |
| -------------------- | ------------------------------------- | --------------------------------------------------------------- |
| **표준 워크플로**| `cmake --build .`                     | 한 단계로 빌드, 모든 테스트 실행, 커버리지 검증을 수행합니다.      |
| **모든 테스트 재실행**  | `ctest`                               | 기존 빌드에서 모든 테스트를 실행합니다.                       |
| **그룹 실행**  | `ctest -L unit`                       | `unit` 레이블이 있는 테스트만 실행합니다.                          |
| **개별 테스트**  | `ctest -R my_feature`              | 이름이 정규식 `my_feature`와 일치하는 테스트를 실행합니다.         |
| **디버깅**        | `./tests/run_all_tests [my_feature]` | CTest를 우회하여 테스트 실행 파일을 직접 실행합니다.             |
